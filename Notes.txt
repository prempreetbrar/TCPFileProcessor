Implement StreamClient:
- Write code to establish TCP connection with StreamServer, read content of file
  from local file system, send it to server for processing, receive the processed file
  content, save it to a new file in the local file system.
- Use a buffer to operate over a block of data for improved performance; size is a design 
  decision but a multiple of TCP packet size is recommended for performance reasons. 
- Sending and receiving must be in separate threads that run concurrently (to avoid deadlock).
- Input and output must be done using FileInputStream and FileOutputStream for File IO, and InputStream 
  and OutputStream for socket IO. 
- Block IO: Read and write operations must use a buffer to perform file and socket IO 
- Concurrency: Read and write operations must be implemented in separate threads to operate concurrently.
- Server processes received data on the fly; it does not save it to a file and process the file. Client side 
  should operate similarly. 
- Concurrent Design: Sending and receiving should be in separate threads, therefore, they cannot block each
  other. One thread for reading input file and sending it to server chunk by chunk. Another thread for
  reading compressed data from the socket chunk by chunk and writing it to the output file. BOTH threads 
  work wtih teh same socket. One reads from it, while the other writes to it. 
- Properly manage thread execution; wait for the threads to finish before closing the socket. 
- Sending Service Code: You can send it to the server as a byte, even though it is represented as an int. 

ExceptionHandling:
- Include ExceptionHandling code to deal with checked exceptions; print all exceptions to standard system
  output. 
- When reading from the socket, println("R " + numBytes)
- When writing to the socket, println("W " + numBytes)
- DO NOT PRINT ANYTHING ELSE TO THE CONSOLE!!!!
- Handle wrong server name error
- Handle non-existent input file error.

Server Implementation:
- Provided in streamserver.jar

Three Services from Server:
- ECHO: Sends back the same data it receives from the client without any modification
- ZIP: Server receives data from client, compresses it using GZIP, sends it back 
- UNZIP: Server receives GZIP compressed data from the client, decompresses it, sends it back 

Important things to Note:
- Server does not know how much data to read from client; keeps reading from socket
  by repeatedly calling inputStream.read() until it returns -1. 
    - This means that at the client side you have to signal when transmission is complete by 
      closing the client's socketOutputStream. However, call shutdownOutput() method so that 
      the inputStream is still working. 

Testing Your Code:
- By running client and server on separate machines, you should see interleaved sequence of read/write 
  operations; use ECHO service for debugging, makes it easy to verify data sent and received for 
  correctness. 
- Must have proper programming style; Javadoc tags, inline code documentation. Only submit the 
  source.java files. Do not compress/zip files. 
- Service code sent to server correctly 
- Sending and receiving operations are concurrent.
- Read and write operations implemented using buffer. 
- Streams and socket are closed properly.
- Server name and port number are not hard coded.
- Both text and binary files are processed correctly. 
